This is a perfect use case for **Svelte** combined with **Tailwind CSS**. Svelte compiles down to tiny vanilla JS (ideal for extension performance), and Tailwind makes building a robust, modern dark-mode UI extremely fast.

Here is a complete project structure and code implementation for your modern **Favicon Manager**.

### Prerequisites

You will need Node.js installed. We will use **Vite** to scaffold the project because it handles extension building very well.

### 1. Project Setup

Open your terminal and run the following commands to set up the project:

```bash

# Create the project

npm create vite@latest favicon-manager -- --template svelte-ts
cd favicon-manager

# Install Tailwind CSS

npm install -D tailwindcss postcss autoprefixer
npx tailwindcss init -p

# Install Lucide Icons (for that modern UI feel) and uuid (for rule IDs)

npm install lucide-svelte uuid clsx tailwind-merge
npm install -D @types/webextension-polyfill
```

### 2. Configuration

#### `tailwind.config.js`

Enable dark mode and set up the content paths.

```javascript
/** @type {import('tailwindcss').Config} */
export default {
  content: ["./src/**/*.{html,js,svelte,ts}"],
  darkMode: "class", // We will force dark mode
  theme: {
    extend: {
      colors: {
        // Modern slate palette
        bg: "#0f172a", // Slate 900
        surface: "#1e293b", // Slate 800
        primary: "#3b82f6", // Blue 500
        border: "#334155", // Slate 700
      },
    },
  },
  plugins: [],
};
```

#### `src/app.css`

Add the Tailwind directives and default dark styling.

```css
@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  @apply bg-bg text-slate-200 antialiased;
}

/* Custom Scrollbar for a refined look */
::-webkit-scrollbar {
  width: 8px;
}
::-webkit-scrollbar-track {
  @apply bg-surface;
}
::-webkit-scrollbar-thumb {
  @apply bg-slate-600 rounded-full hover:bg-slate-500;
}
```

### 3. The Manifest (Firefox V3)

Create a file named `manifest.json` in the **`public`** folder.

```json
{
  "manifest_version": 3,
  "name": "Favicon Master",
  "version": "1.0.0",
  "description": "Modern Custom Favicon Manager",
  "permissions": ["storage", "tabs"],
  "host_permissions": ["<all_urls>"],
  "options_ui": {
    "page": "options.html",
    "open_in_tab": true
  },
  "content_scripts": [
    {
      "matches": ["<all_urls>"],
      "js": ["content-script.js"],
      "run_at": "document_start"
    }
  ],
  "browser_specific_settings": {
    "gecko": {
      "id": "favicon-master@yourdomain.com",
      "strict_min_version": "109.0"
    }
  }
}
```

### 4. Core Logic & Types

Create `src/lib/types.ts`:

```typescript
export interface Rule {
  id: string;
  name: string;
  enabled: boolean;
  matchType: "contains" | "regex";
  pattern: string;
  sourceType: "url" | "base64" | "preset";
  value: string; // The URL, Base64 string, or Preset filename
}

export const PRESETS = [
  "shield.png",
  "terminal.png",
  "heart.png",
  "code.png",
  // You would put actual files in public/presets/
];
```

### 5. The Content Script

Since this is a Vite build, we need to treat the content script specially or copy it manually. For simplicity in this setup, create `public/content-script.js`.

_Note: In a production Vite setup, you might compile this TS file separately, but raw JS is fine here._

```javascript
// public/content-script.js

(async () => {
  const { rules } = await browser.storage.sync.get("rules");
  if (!rules) return;

  const currentUrl = window.location.href;

  const activeRule = rules.find((rule) => {
    if (!rule.enabled) return false;

    if (rule.matchType === "regex") {
      try {
        const regex = new RegExp(rule.pattern);
        return regex.test(currentUrl);
      } catch (e) {
        return false;
      }
    } else {
      return currentUrl.includes(rule.pattern);
    }
  });

  if (activeRule) {
    updateFavicon(activeRule);
  }
})();

function updateFavicon(rule) {
  let iconUrl = rule.value;

  // Handle presets pathing
  if (rule.sourceType === "preset") {
    iconUrl = browser.runtime.getURL(`presets/${rule.value}`);
  }

  const setIcon = () => {
    const links = document.querySelectorAll("link[rel*='icon']");
    // Remove existing
    links.forEach((link) => link.remove());

    // Create new
    const link = document.createElement("link");
    link.type = "image/x-icon";
    link.rel = "shortcut icon";
    link.href = iconUrl;
    document.getElementsByTagName("head")[0].appendChild(link);
  };

  // Run immediately
  setIcon();

  // Watch for dynamic changes (SPAs like React/Vue apps often overwrite head)
  const observer = new MutationObserver(setIcon);
  observer.observe(document.querySelector("head"), {
    childList: true,
    subtree: true,
  });
}
```

### 6. The Settings UI (Svelte)

We need an entry point for the Options page.
Create `options.html` in the root (move it to root if it's in public, or configure vite input). Actually, for Vite + Svelte standard, use `index.html` as the options page for development.

#### `src/lib/components/RuleModal.svelte`

(The Modal to Add/Edit rules)

```svelte
<script lang="ts">
  import { createEventDispatcher } from 'svelte';
  import type { Rule } from '../types';
  import { PRESETS } from '../types';
  import { X, Upload } from 'lucide-svelte';

  export let rule: Rule;
  export let isOpen: boolean;

  const dispatch = createEventDispatcher();

  function save() {
    dispatch('save', rule);
    isOpen = false;
  }

  function handleFileUpload(e: Event) {
    const file = (e.target as HTMLInputElement).files?.[0];
    if (file) {
      const reader = new FileReader();
      reader.onloadend = () => {
        rule.value = reader.result as string;
        rule.sourceType = 'base64';
      };
      reader.readAsDataURL(file);
    }
  }
</script>

{#if isOpen}
  <div class="fixed inset-0 z-50 flex items-center justify-center bg-black/70 backdrop-blur-sm">
    <div class="w-full max-w-lg rounded-xl border border-border bg-surface p-6 shadow-2xl">
      <div class="mb-6 flex items-center justify-between">
        <h2 class="text-xl font-bold text-white">
          {rule.id ? 'Edit Rule' : 'New Rule'}
        </h2>
        <button on:click={() => (isOpen = false)} class="text-slate-400 hover:text-white">
          <X size={20} />
        </button>
      </div>

      <div class="space-y-4">
        <!-- Name -->
        <div>
          <label class="mb-1 block text-sm font-medium text-slate-400">Rule Name</label>
          <input bind:value={rule.name} type="text" class="w-full rounded-lg border border-border bg-bg p-2 text-white focus:border-primary focus:outline-none" placeholder="e.g. Localhost Dev" />
        </div>

        <!-- Pattern -->
        <div class="grid grid-cols-3 gap-4">
          <div class="col-span-1">
            <label class="mb-1 block text-sm font-medium text-slate-400">Match Type</label>
            <select bind:value={rule.matchType} class="w-full rounded-lg border border-border bg-bg p-2 text-white">
              <option value="contains">Contains</option>
              <option value="regex">Regex</option>
            </select>
          </div>
          <div class="col-span-2">
            <label class="mb-1 block text-sm font-medium text-slate-400">URL Pattern</label>
            <input bind:value={rule.pattern} type="text" class="w-full rounded-lg border border-border bg-bg p-2 text-white focus:border-primary focus:outline-none" placeholder="e.g. localhost:3000" />
          </div>
        </div>

        <!-- Icon Source -->
        <div>
          <label class="mb-1 block text-sm font-medium text-slate-400">Icon Source</label>
          <div class="flex gap-2 rounded-lg bg-bg p-1">
            {#each ['url', 'base64', 'preset'] as type}
              <button
                class="flex-1 rounded py-1 text-sm capitalize transition-colors {rule.sourceType === type ? 'bg-primary text-white' : 'text-slate-400 hover:text-white'}"
                on:click={() => rule.sourceType = type as any}
              >
                {type}
              </button>
            {/each}
          </div>
        </div>

        <!-- Icon Input Area -->
        <div class="mt-2 rounded-lg border border-border bg-bg p-4">
          {#if rule.sourceType === 'url'}
            <input bind:value={rule.value} type="text" class="w-full bg-transparent text-sm text-white focus:outline-none" placeholder="https://example.com/icon.png" />
          {:else if rule.sourceType === 'base64'}
             <div class="flex items-center gap-4">
                <label class="cursor-pointer flex items-center gap-2 rounded bg-surface px-3 py-2 text-sm hover:bg-slate-700 border border-border">
                   <Upload size={16}/> Upload Image
                   <input type="file" class="hidden" accept="image/*" on:change={handleFileUpload} />
                </label>
                <span class="text-xs text-slate-500 truncate max-w-[200px]">{rule.value ? 'Image loaded' : 'No image selected'}</span>
             </div>
          {:else}
            <div class="flex gap-3 overflow-x-auto pb-2">
               {#each PRESETS as preset}
                  <button
                    on:click={() => rule.value = preset}
                    class="h-10 w-10 shrink-0 rounded border-2 p-1 {rule.value === preset ? 'border-primary bg-primary/20' : 'border-transparent hover:bg-slate-800'}"
                  >
                    <!-- In real app, use full path -->
                    <img src="/presets/{preset}" class="h-full w-full object-contain" alt={preset} />
                  </button>
               {/each}
            </div>
          {/if}
        </div>

        <!-- Preview -->
        <div class="flex items-center justify-center pt-2">
            <span class="mr-3 text-sm text-slate-400">Preview:</span>
            <div class="flex h-12 w-12 items-center justify-center rounded-lg bg-white p-2">
                {#if rule.sourceType === 'preset'}
                    <img src="/presets/{rule.value}" class="h-8 w-8 object-contain" alt="preview" />
                {:else if rule.value}
                    <img src={rule.value} class="h-8 w-8 object-contain" alt="preview" />
                {:else}
                    <div class="h-8 w-8 rounded bg-slate-200"></div>
                {/if}
            </div>
        </div>

      </div>

      <div class="mt-6 flex justify-end gap-3">
        <button on:click={() => (isOpen = false)} class="rounded-lg px-4 py-2 text-sm font-medium text-slate-300 hover:text-white">Cancel</button>
        <button on:click={save} class="rounded-lg bg-primary px-4 py-2 text-sm font-medium text-white hover:bg-blue-600">Save Rule</button>
      </div>
    </div>
  </div>
{/if}
```

#### `src/App.svelte`

(The main Settings Dashboard)

```svelte
<script lang="ts">
  import { onMount } from 'svelte';
  import { v4 as uuidv4 } from 'uuid';
  import { Plus, Trash2, Edit, Search } from 'lucide-svelte';
  import RuleModal from './lib/components/RuleModal.svelte';
  import type { Rule } from './lib/types';

  let rules: Rule[] = [];
  let isModalOpen = false;
  let editingRule: Rule | null = null;
  let searchQuery = '';

  // Load rules on mount
  onMount(async () => {
    // Check if browser extension API exists (dev mode fallback)
    if (typeof browser !== 'undefined' && browser.storage) {
      const stored = await browser.storage.sync.get('rules');
      rules = stored.rules || [];
    } else {
      // Mock data for local development
      rules = [
        { id: '1', name: 'Google Dev', enabled: true, matchType: 'contains', pattern: 'google.com', sourceType: 'preset', value: 'shield.png' }
      ];
    }
  });

  async function saveRules() {
    rules = rules; // trigger update
    if (typeof browser !== 'undefined' && browser.storage) {
      await browser.storage.sync.set({ rules });
    }
  }

  function openNewRule() {
    editingRule = {
      id: uuidv4(),
      name: '',
      enabled: true,
      matchType: 'contains',
      pattern: '',
      sourceType: 'preset',
      value: 'shield.png'
    };
    isModalOpen = true;
  }

  function editRule(rule: Rule) {
    editingRule = { ...rule }; // clone
    isModalOpen = true;
  }

  function handleSave(event: CustomEvent<Rule>) {
    const newRule = event.detail;
    const index = rules.findIndex(r => r.id === newRule.id);
    if (index >= 0) {
      rules[index] = newRule;
    } else {
      rules = [...rules, newRule];
    }
    saveRules();
  }

  function deleteRule(id: string) {
    rules = rules.filter(r => r.id !== id);
    saveRules();
  }

  function toggleRule(rule: Rule) {
    rule.enabled = !rule.enabled;
    saveRules();
  }

  $: filteredRules = rules.filter(r =>
    r.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
    r.pattern.toLowerCase().includes(searchQuery.toLowerCase())
  );
</script>

<main class="min-h-screen bg-bg p-8 text-slate-200">
  <div class="mx-auto max-w-5xl">

    <!-- Header -->
    <header class="mb-10 flex items-center justify-between">
      <div>
        <h1 class="text-3xl font-bold text-white">Favicon Master</h1>
        <p class="text-slate-400">Manage your custom browser identities</p>
      </div>
      <button
        on:click={openNewRule}
        class="flex items-center gap-2 rounded-lg bg-primary px-4 py-2 font-medium text-white shadow-lg shadow-blue-500/20 hover:bg-blue-600 transition-all"
      >
        <Plus size={18} /> Add Rule
      </button>
    </header>

    <!-- Search / Filter Bar -->
    <div class="mb-6 flex items-center rounded-xl border border-border bg-surface px-4 py-3">
      <Search size={20} class="text-slate-400" />
      <input
        bind:value={searchQuery}
        type="text"
        placeholder="Search rules..."
        class="ml-3 w-full bg-transparent text-sm focus:outline-none"
      />
    </div>

    <!-- Rules Table -->
    <div class="overflow-hidden rounded-xl border border-border bg-surface">
      <table class="w-full text-left">
        <thead class="bg-slate-900/50 text-xs uppercase text-slate-400">
          <tr>
            <th class="px-6 py-4">Enabled</th>
            <th class="px-6 py-4">Preview</th>
            <th class="px-6 py-4">Name</th>
            <th class="px-6 py-4">Match Pattern</th>
            <th class="px-6 py-4 text-right">Actions</th>
          </tr>
        </thead>
        <tbody class="divide-y divide-border">
          {#each filteredRules as rule (rule.id)}
            <tr class="group hover:bg-slate-700/30 transition-colors">
              <td class="px-6 py-4">
                 <button
                  on:click={() => toggleRule(rule)}
                  class="relative h-6 w-11 rounded-full transition-colors {rule.enabled ? 'bg-primary' : 'bg-slate-600'}"
                 >
                   <span class="absolute left-1 top-1 h-4 w-4 rounded-full bg-white transition-transform {rule.enabled ? 'translate-x-5' : 'translate-x-0'}" />
                 </button>
              </td>
              <td class="px-6 py-4">
                <div class="flex h-10 w-10 items-center justify-center rounded bg-white p-1">
                  {#if rule.sourceType === 'preset'}
                    <img src="/presets/{rule.value}" alt="" class="max-h-full max-w-full" />
                  {:else}
                    <img src={rule.value} alt="" class="max-h-full max-w-full" />
                  {/if}
                </div>
              </td>
              <td class="px-6 py-4 font-medium text-white">{rule.name}</td>
              <td class="px-6 py-4">
                <div class="flex flex-col">
                  <span class="text-sm text-slate-200">{rule.pattern}</span>
                  <span class="text-xs text-slate-500 uppercase">{rule.matchType}</span>
                </div>
              </td>
              <td class="px-6 py-4 text-right">
                <div class="flex justify-end gap-2 opacity-0 group-hover:opacity-100 transition-opacity">
                  <button on:click={() => editRule(rule)} class="rounded p-2 text-slate-400 hover:bg-slate-700 hover:text-white">
                    <Edit size={16} />
                  </button>
                  <button on:click={() => deleteRule(rule.id)} class="rounded p-2 text-slate-400 hover:bg-red-500/20 hover:text-red-400">
                    <Trash2 size={16} />
                  </button>
                </div>
              </td>
            </tr>
          {/each}
        </tbody>
      </table>
      {#if filteredRules.length === 0}
        <div class="p-8 text-center text-slate-500">
          No rules found. Create one to get started!
        </div>
      {/if}
    </div>
  </div>

  {#if editingRule}
    <RuleModal
      bind:isOpen={isModalOpen}
      bind:rule={editingRule}
      on:save={handleSave}
    />
  {/if}
</main>

<style>
  :global(body) {
    background-color: #0f172a; /* Tailwind bg-slate-900 */
  }
</style>
```

### 7. Build and Run

1.  **Mock Presets**: Create a folder `public/presets` and drop some PNG files in there (e.g., `shield.png`).
2.  **Build**:
    ```bash
    npm run build
    ```
3.  **Load in Firefox**:
    - Open `about:debugging`
    - Click "This Firefox"
    - Click "Load Temporary Add-on"
    - Select the `manifest.json` file inside your `dist` (or `public` depending on vite config, usually `dist` after build) folder.
    - _Note on Vite:_ Vite puts everything in `dist`. Ensure your manifest is copied there. If `npm run build` doesn't copy `manifest.json` automatically, you may need a plugin like `vite-plugin-static-copy` or just manually copy it for testing.

**Fixing the Options Page path:**
In `vite.config.ts`, you typically want to define the build input so it generates the `options.html` correctly.

```typescript
// vite.config.ts
import { defineConfig } from "vite";
import svelte from "@sveltejs/vite-plugin-svelte";
import { resolve } from "path";

export default defineConfig({
  plugins: [svelte()],
  build: {
    rollupOptions: {
      input: {
        options: resolve(__dirname, "index.html"),
        // You might want to compile the content script here too,
        // but simple inclusion in public works for MVP
      },
    },
  },
});
```

### Key Design Features Implemented:

1.  **Dark Mode First**: Uses Slate-900/800 hierarchy for depth.
2.  **Modern Table**: Hover effects, clean typography, visual switches.
3.  **Robust Input**:
    - **Base64**: Handles file uploads automatically converting to Base64 strings.
    - **Presets**: Visual grid selector.
    - **Regex/Contains**: Explicit toggle.
4.  **UX**: Search filtering, modal based editing (prevents clutter), instant preview of the favicon.
